plugins {
    id('java')
    id('application')
    id('org.beryx.jlink') version "$beryxPluginVersion"
    id('com.gradleup.shadow') version "$shadowPluginVersion"
    id('org.gradlex.extra-java-module-info') version "$extraModuleInfoPluginVersion"
}

version = rootProject.version
group = 'net.brlns'

def author = 'Gabriel D @hstr0100'
def lowercaseName = 'gdownloader'

def os = org.gradle.internal.os.OperatingSystem.current()

def getArchitecture(def os) {
    def arch = System.getProperty("os.arch").toLowerCase()
    if (arch.contains("aarch64") || arch.contains("arm64")) {
        return os.isLinux() ? "aarch64" : "arm64"
    } else if (arch.contains("arm")) {
        return os.isLinux() ? "armhf" : "arm"
    } else if (arch.contains("64")) {
        return os.isLinux() ? "amd64" : "x64"
    } else {
        return os.isLinux() ? "i386" : "x86"
    }
}

def architecture = getArchitecture(os)

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21

    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }

    // There seems to be no consensus whatsoever on whether to use .set() or =.
    // Personally, I prefer = for consistency, and .set() for a cleaner-looking syntax.
    // Perhaps we can settle on a mix of both approaches.

    modularity.inferModulePath.set(true)
}

application {
    mainClass.set('net.brlns.gdownloader.GDownloader')
    mainModule.set('net.brlns.gdownloader')
    applicationDefaultJvmArgs = ['--add-exports=java.management/sun.management=ALL-UNNAMED']
}

dependencies {
    implementation(project(path: ':twelvemonkeys', configuration: 'moduleJar'))
    implementation("ch.qos.logback:logback-classic:$logbackVersion")
    implementation("com.github.kwhat:jnativehook:$jnativehookVersion")
    implementation("com.fasterxml.jackson.core:jackson-databind:$jacksonVersion")
    implementation("org.jsoup:jsoup:$jsoupVersion")
    implementation("org.slf4j:slf4j-api:$slf4jVersion")
    implementation("net.java.dev.jna:jna:$jnaVersion")
    implementation("net.java.dev.jna:jna-platform:$jnaVersion")
    implementation("jakarta.annotation:jakarta.annotation-api:$jakartaAnnotationVersion")
    implementation("jakarta.persistence:jakarta.persistence-api:$jakartaPersistenceVersion")
    implementation("org.eclipse.persistence:eclipselink:$eclipselinkVersion")
    implementation("org.hsqldb:hsqldb:$hsqldbVersion")
    implementation("com.adonax:audiocue:$adonaxVersion")

    compileOnly("org.projectlombok:lombok:$lombokVersion")
    annotationProcessor("org.projectlombok:lombok:$lombokVersion")
    testImplementation("org.junit.jupiter:junit-jupiter:$jupiterVersion")
    testRuntimeOnly('org.junit.platform:junit-platform-launcher')
}

test {
    useJUnitPlatform()
}

run {
    enableAssertions = true
}

tasks.named('run') {
    jvmArgs = ['-Xss5M']
}

extraJavaModuleInfo {
    failOnMissingModuleInfo.set(true)
    deriveAutomaticModuleNamesFromFileNames.set(true)

    module("twelvemonkeys-$twelvemonkeysVersion-all.jar", 'com.twelvemonkeys.imageio') {
        requiresStatic('java.desktop')

        exports('com.twelvemonkeys.imageio.stream')
        exports('com.twelvemonkeys.imageio.color')
        exports('com.twelvemonkeys.imageio.plugins.jpeg')
        exports('com.twelvemonkeys.imageio.plugins.webp')
        exports('com.twelvemonkeys.imageio.plugins.tiff')
    }

    automaticModule('net.java.dev.jna:jna', 'com.sun.jna') {
        overrideModuleName()
    }
}

tasks.withType(JavaCompile).configureEach {
    options.compilerArgs.addAll(['-Xlint:all,-serial,-processing,-requires-automatic,-missing-explicit-ctor'])
}

jar {
    archiveBaseName.set("${lowercaseName}-java")

    manifest {
        attributes(
            'Implementation-Title': rootProject.name,
            'Implementation-Version': version,
            'Implementation-Vendor': author,
            'Main-Class': application.mainClass.get()
        )
    }

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

shadowJar {
    archiveBaseName.set("${lowercaseName}-java")
    mergeServiceFiles()
}

// Workaround for https://github.com/gradle/gradle/issues/26155 and https://github.com/johnrengelman/shadow/issues/882
tasks.named('shadowJar') { shadowJar ->
    inputs.files(project.configurations.runtimeClasspath)
    configurations = []

    doFirst {
        configurations = [project.configurations.runtimeClasspath]
    }
}

task zipJpackageImage(type: Zip) {
    def fileName = os.isWindows() ? "${lowercaseName}-${version}-windows_portable_${architecture}.zip" :
                   os.isLinux() ? "${lowercaseName}-${version}-linux_portable_${architecture}.zip" :
                   "${lowercaseName}-${version}-mac_portable_${architecture}.zip"

    archiveFileName.set(fileName)
    destinationDirectory.set(file("$buildDir/jpackage"))

    // A less-than-stellar but functional way to detect that the program is running in portable mode.
    doFirst {
        def basePath = os.isWindows() ? "$buildDir/jpackage/${rootProject.name}" :
                       os.isLinux() ? "$buildDir/jpackage/${rootProject.name}/lib" :
                       "$buildDir/jpackage/${rootProject.name}.app/Contents"

        def portableLockFile = file("$basePath/runtime/portable.lock")
        portableLockFile.text = [
            "This file ensures that the program will run in portable mode.",
            "Deleting it when the program is not installed is not recommended."
        ].join("\n")
    }

    from("$buildDir/jpackage/${rootProject.name}")
}

tasks.jpackage.finalizedBy zipJpackageImage

jlink {
    options = ['--strip-debug', '--compress', 'zip-6', '--no-header-files', '--no-man-pages']

    launcher {
        name = 'GDownloader'
        jvmArgs = ['-Xmx2G', '-Xss5M']
        noConsole = true
    }

    jpackage {
        jvmArgs = ['-Djnativehook.lib.locator=net.brlns.gdownloader.util.CustomNativeLocator']

        def imgType = os.isWindows() ? 'ico' : os.isMacOsX() ? 'icns' : 'png'
        icon = "src/main/resources/assets/launcher/GDownloader.$imgType"

        installerOptions += [
            '--about-url', 'https://github.com/hstr0100/GDownloader',
            '--description', 'Graphical interface for yt-dlp, gallery-dl, and spotDL',
            '--vendor', author,
            '--copyright', "2025 ${author}",
            '--license-file', "../LICENSE",
            '--app-version', version
        ]

        if (os.isWindows()) {
            installerName = "${lowercaseName}-windows-${architecture}"
            installerType = 'msi'
            //imageOptions += ['--win-console']
            installerOptions += [
                '--win-per-user-install',
                '--win-dir-chooser',
                '--win-menu',
                '--win-menu-group', "${rootProject.name}",
                '--win-shortcut'
            ]
        } else if (os.isLinux()) {
            // AppImage not yet supported by jpackage
            installerType = 'deb'
            installerOptions += [
                '--resource-dir', "build/jpackage/${rootProject.name}/lib/app",
                '--linux-package-name', "${lowercaseName}-linux",
                '--linux-app-category', 'web',
                '--linux-menu-group', 'Network;',
                '--linux-deb-maintainer', 'brokenlensllc@gmail.com',
                '--linux-rpm-license-type', 'GPLv3',
                '--linux-shortcut'
            ]
        } else if (os.isMacOsX()) {
            installerName = "${lowercaseName}-mac-${architecture}"
            installerType = 'dmg'
            installerOptions += [
                '--mac-package-name', "${rootProject.name}"
            ]
        }
    }
}

tasks.jpackage.doFirst {
    def basePath = os.isWindows() ? rootProject.name :
                   os.isLinux() ? "${rootProject.name}/lib" :
                   "${rootProject.name}.app/Contents"

    copy {
        from('src/main/resources/assets/launcher')
        include('GDownloader.png')
        include('GDownloader.icns')
        include('GDownloader.ico')
        into("$buildDir/jpackage/$basePath/app")
    }
}

configurations {
    resolvableImplementation { extendsFrom implementation }
}

tasks.jlink.doLast {
    configurations.resolvableImplementation.files.findAll { f ->
        f.name.contains('jnativehook')
    }.each { nativeJar ->
        def destDir = file("$imageDir/bin/native-libs")
        delete(destDir)
        mkdir(destDir)

        def baseLibPath = 'com/github/kwhat/jnativehook/lib'
        def zt = zipTree(nativeJar).matching {
            include("$baseLibPath/**")
        }

        def expandedPath = zt.asFileTree.tree.mirror.dir.path
        zt.files.each { f ->
            def pathInLib = (f.path - expandedPath).substring(1)
            pathInLib = pathInLib.replace('\\', '/')
            pathInLib -= "$baseLibPath/"
            def destFilePath = destDir.toPath().resolve(pathInLib)
            mkdir(destFilePath.parent)
            java.nio.file.Files.copy(f.toPath(), destFilePath)
        }
    }
}

task createAppImage(type: Exec, dependsOn: zipJpackageImage) {
    group = 'distribution'
    onlyIf { os.isLinux() }

    def appImageArch
    if (architecture == "arm64" || architecture == "aarch64") {
        appImageArch = "aarch64"
    } else if (architecture == "arm" || architecture == "armhf") {
        appImageArch = "armhf"
    } else if (architecture == "x64" || architecture == "amd64") {
        appImageArch = "x86_64"
    } else {
        appImageArch = "i686"
    }

    def appDirBase = file("$buildDir/appimage")

    doFirst {
        def portableZip = file("$buildDir/jpackage/${lowercaseName}-${version}-linux_portable_${architecture}.zip")
        def appDir = file("$appDirBase/AppDir")
        def appUsrPath = "$appDir/usr"
        def appLibPath = "$appUsrPath/lib/${lowercaseName}"

        delete(appDirBase)
        mkdir(appDirBase)

        copy {
            from zipTree(portableZip)
            into appDirBase
        }

        file("$appUsrPath/bin").mkdirs()
        file("$appUsrPath/share/applications").mkdirs()
        file("$appUsrPath/share/icons/hicolor/256x256/apps").mkdirs()

        copy {
            from appDirBase
            into "$appLibPath"
            include "**"
            exclude "AppDir/**"
        }

        delete("$appLibPath/lib/runtime/portable.lock")

        def launcherScript = file("$appUsrPath/bin/${lowercaseName}")
        launcherScript.text = [
            "#!/bin/bash",
            "cd \"\$(dirname \"\$(readlink -f \"\$0\")\")/../lib/${lowercaseName}\"",
            "exec ./bin/GDownloader \"\$@\""
        ].join("\n")
        launcherScript.setExecutable(true, false)

        def iconPath = "$appLibPath/lib/app/GDownloader.png"

        [
            "$appDir/${lowercaseName}.png",
            "$appUsrPath/share/icons/hicolor/256x256/apps/${lowercaseName}.png",
            "$appDir/.DirIcon"
        ].each { destPath ->
            copy {
                from iconPath
                into file(destPath).parent
                rename { file(destPath).name }
            }
        }

        def desktopFileContent = [
            "[Desktop Entry]",
            "Name=${rootProject.name}",
            "Exec=${lowercaseName}",
            "Icon=${lowercaseName}",
            "Type=Application",
            "Categories=Network;",
            "Comment=Graphical interface for yt-dlp, gallery-dl, and spotDL",
            "Terminal=false"
        ].join("\n")

        [
            file("$appUsrPath/share/applications/${lowercaseName}.desktop"),
            file("$appDir/${lowercaseName}.desktop")
        ].each {
            it.text = desktopFileContent
            it.setExecutable(true, false)
        }

        def appRun = file("$appDir/AppRun")
        appRun.text = [
            "#!/bin/bash",
            "HERE=\"\$(dirname \"\$(readlink -f \"\${0}\")\")\"",
            "NATIVES=\"\${HERE}/usr/lib/${lowercaseName}/lib/runtime/bin/native-libs/linux/${appImageArch}\"",
            "export PATH=\"\${HERE}/usr/bin:\${PATH}\"",
            "export LD_LIBRARY_PATH=\"\${HERE}/usr/lib/${lowercaseName}/lib:\${NATIVES}:\${LD_LIBRARY_PATH}\"",
            "exec \"\${HERE}/usr/bin/${lowercaseName}\" \"\$@\""
        ].join("\n")
        appRun.setExecutable(true, false)
    }

    // Build image
    def appImageName = "${lowercaseName}-${version}-${appImageArch}.AppImage"
    workingDir "$buildDir/appimage"
    environment "ARCH", appImageArch

    // this requires appimagetool (without extension and version number) to be in your PATH
    // https://github.com/AppImage/appimagetool/releases
    commandLine "appimagetool", "--verbose", "-n", "AppDir", appImageName

    doLast {
        copy {
            from "$buildDir/appimage/${appImageName}"
            into "$buildDir/jpackage"
        }

        delete fileTree(appDirBase) {
            exclude 'AppDir/**'
        }

        println "Created AppImage at: $buildDir/jpackage/${appImageName}"
    }
}

task printJpackageContents {
    doLast {
        def jpackageDir = file("$buildDir/jpackage")
        if (jpackageDir.exists() && jpackageDir.isDirectory()) {
            println "Build complete, generated binaries:"

            jpackageDir.eachFile { file ->
                if (file.isFile()) {
                    println "- ${file.absolutePath}"
                }
            }
        } else {
            println "jpackage directory is missing or not a directory: ${jpackageDir.path}"
        }
    }
}

tasks.zipJpackageImage.finalizedBy printJpackageContents
tasks.createAppImage.finalizedBy printJpackageContents
